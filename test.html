<!DOCTYPE html>
<html>
<head>
    <title>Web Audio API copyFromChannel Test</title>
</head>
<body>
    <h1>copyFromChannel Test</h1>
    <div id="log"></div>

    <script>
        let logDiv = document.getElementById('log');
        let testCount = 0;

        function log(msg) {
            logDiv.innerHTML += '<div>' + msg + '</div>';
            console.log(msg);
            testCount++;
        }

        function calculateRMS(data) {
            let sum = 0;
            for (let i = 0; i < data.length; i++) {
                sum += data[i] * data[i];
            }
            return Math.sqrt(sum / data.length);
        }

        async function runTests() {
            log('üöÄ Starting Web Audio API copyFromChannel Tests');

            // Initialize Web Audio Context (same as our app)
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            log('AudioContext created with sample rate: ' + ctx.sampleRate);
            log('AudioContext state: ' + ctx.state);

            // Debug 1: Check AudioBuffer creation and basic properties
            log('<br>üîß DEBUG: AudioBuffer Creation');
            const testBuffer = ctx.createBuffer(1, 4096, ctx.sampleRate);
            log('Test buffer created - length: ' + testBuffer.length);
            log('Test buffer sampleRate: ' + testBuffer.sampleRate);
            log('Test buffer numberOfChannels: ' + testBuffer.numberOfChannels);

            // Debug 2: Check getChannelData() behavior
            const channelData = testBuffer.getChannelData(0);
            log('Channel data constructor: ' + channelData.constructor.name);
            log('Channel data length: ' + channelData.length);
            log('Channel data isFrozen: ' + Object.isFrozen(channelData));
            log('Channel data extensible: ' + Object.isExtensible(channelData));

            // Test if we can write to the buffer at all
            const originalValue = channelData[0];
            channelData[0] = 0.999; // Try to write
            const newValue = channelData[0];
            log('Write test: original=' + originalValue + ', after write=' + newValue + ' SUCCESS=' + (newValue === 0.999));

            if (newValue !== 0.999) {
                log('‚ùå CRITICAL: Cannot write to AudioBuffer channel data!');
                log('This explains why all copy methods fail completely');
            }

            // Test 1: All zeros (like silent chunks we see)
            log('<br>üß™ TEST 1: All Zeros (Silent Chunk)');
            const zeros = new Float32Array(4096).fill(0);
            log('Input RMS: ' + calculateRMS(zeros).toFixed(6));
            const buffer1 = ctx.createBuffer(1, zeros.length, ctx.sampleRate);
            buffer1.copyFromChannel(zeros, 0);
            const out1 = buffer1.getChannelData(0);
            log('Output RMS: ' + calculateRMS(out1).toFixed(6));
            log('First 5: ' + Array.from(out1.slice(0,5)).map(x => x.toFixed(6)).join(', '));

            // Test 2: Real audio data (sine wave)
            log('<br>üß™ TEST 2: Real Audio Data (Sine Wave)');
            const freq = 440; // 440Hz tone
            const audio = new Float32Array(4096);
            for (let i = 0; i < 4096; i++) {
                audio[i] = 0.3 * Math.sin(2 * Math.PI * freq * i / ctx.sampleRate);
            }
            log('Input RMS: ' + calculateRMS(audio).toFixed(6));
            const buffer2 = ctx.createBuffer(1, audio.length, ctx.sampleRate);
            buffer2.copyFromChannel(audio, 0);
            const out2 = buffer2.getChannelData(0);
            log('Output RMS: ' + calculateRMS(out2).toFixed(6));
            log('First 5: ' + Array.from(out2.slice(0,5)).map(x => x.toFixed(6)).join(', '));

            // Test 3: Mixed silence + audio (exactly like our recording problem)
            log('<br>üß™ TEST 3: Mixed Silence + Audio (Copy of Our Problem)');
            const mixed = new Float32Array(4096);
            // First half: zeros (like our silent chunks)
            // Second half: real audio
            for (let i = 0; i < 4096; i++) {
                if (i < 2048) {
                    mixed[i] = 0; // silence
                } else {
                    mixed[i] = 0.3 * Math.sin(2 * Math.PI * freq * (i - 2048) / ctx.sampleRate);
                }
            }
            log('Input RMS: ' + calculateRMS(mixed).toFixed(6));
            const buffer3 = ctx.createBuffer(1, mixed.length, ctx.sampleRate);
            buffer3.copyFromChannel(mixed, 0);
            const out3 = buffer3.getChannelData(0);
            log('Output RMS: ' + calculateRMS(out3).toFixed(6));
            log('First 5: ' + Array.from(out3.slice(0,5)).map(x => x.toFixed(6)).join(', '));
            log('Mid 5 (around 2048): ' + Array.from(out3.slice(2048,2053)).map(x => x.toFixed(6)).join(', '));

            // Test 4: Multiple chunks flattened (like our recording concatenation) - BROKEN copyFromChannel
            log('<br>üß™ TEST 4: Multiple Chunks (Silence + Audio) - copyFromChannel');
            const chunk1 = new Float32Array(4096).fill(0); // silent chunk
            const chunk2 = new Float32Array(4096);
            for (let i = 0; i < 4096; i++) {
                chunk2[i] = 0.3 * Math.sin(2 * Math.PI * freq * i / ctx.sampleRate);
            }
            const flattened = new Float32Array(8192);
            flattened.set(chunk1, 0);     // silent chunk first
            flattened.set(chunk2, 4096);  // audio chunk second
            log('Flattened RMS: ' + calculateRMS(flattened).toFixed(6));

            const buffer4 = ctx.createBuffer(1, flattened.length, ctx.sampleRate);
            buffer4.copyFromChannel(flattened, 0);
            const out4 = buffer4.getChannelData(0);
            log('Final RMS (copyFromChannel): ' + calculateRMS(out4).toFixed(6));
            log('First 5 (copyFromChannel): ' + Array.from(out4.slice(0,5)).map(x => x.toFixed(6)).join(', '));

            // Test 5: Same data but with .set() method (the fix!)
            log('<br>üß™ TEST 5: Multiple Chunks (Silence + Audio) - getChannelData(0).set()');
            const buffer5 = ctx.createBuffer(1, flattened.length, ctx.sampleRate);
            buffer5.getChannelData(0).set(flattened);  // THE FIX!
            const out5 = buffer5.getChannelData(0);
            log('Final RMS (.set() method): ' + calculateRMS(out5).toFixed(6));
            log('First 5 (.set() method): ' + Array.from(out5.slice(0,5)).map(x => x.toFixed(6)).join(', '));
            log('Last 5 (.set() method): ' + Array.from(out5.slice(-5)).map(x => x.toFixed(6)).join(', '));

            // Test 6: Manual Array Loop Copy (PROPOSED SOLUTION)
            log('<br>üß™ TEST 6: Manual Array Copy Loop (Real Solution)');
            const buffer6 = ctx.createBuffer(1, flattened.length, ctx.sampleRate);
            const channelData6 = buffer6.getChannelData(0);

            // MANUAL LOOP COPY - The proposed solution
            for(let i = 0; i < flattened.length; i++) {
                channelData6[i] = flattened[i];
            }

            const out6 = buffer6.getChannelData(0);
            log('Manual loop RMS: ' + calculateRMS(out6).toFixed(6));
            log('First 5 (manual loop): ' + Array.from(out6.slice(0,5)).map(x => x.toFixed(6)).join(', '));
            log('Last 5 (manual loop): ' + Array.from(out6.slice(-5)).map(x => x.toFixed(6)).join(', '));
            log('Manual loop data preserved? ' + (calculateRMS(out6) > 0.001 ? 'Yes ‚úÖ' : 'No ‚ùå'));

            // Test 7: Side-by-Side Comparison of ALL methods
            log('<br>üß™ TEST 7: Final Comparison (Which Method Works?)');
            log('copyFromChannel RMS: ' + calculateRMS(out4).toFixed(6) + (calculateRMS(out4) > 0.001 ? ' ‚úÖ' : ' ‚ùå'));
            log('.set() method RMS: ' + calculateRMS(out5).toFixed(6) + (calculateRMS(out5) > 0.001 ? ' ‚úÖ' : ' ‚ùå'));
            log('Manual loop RMS: ' + calculateRMS(out6).toFixed(6) + (calculateRMS(out6) > 0.001 ? ' ‚úÖ' : ' ‚ùå'));

            const copyFromChannelWorks = calculateRMS(out4) > 0.001;
            const setMethodWorks = calculateRMS(out5) > 0.001;
            const manualLoopWorks = calculateRMS(out6) > 0.001;

            log('<br>üéØ CONCLUSION:');
            if (manualLoopWorks) {
                log('‚úÖ MANUAL LOOP WORKS - Use this for recording fix!');
            } else if (setMethodWorks) {
                log('‚úÖ .SET() WORKS - Use this for recording fix!');
            } else if (copyFromChannelWorks) {
                log('‚úÖ COPYFROMCHANNEL WORKS - But suspiciously rare!');
            } else {
                log('‚ùå ALL METHODS FAIL - Need complete rebuild!');
            }

            log('<br>‚úÖ All tests complete! Check conclusion above.');
        }

        // Run tests on page load
        runTests().catch(console.error);
    </script>
</body>
</html>
